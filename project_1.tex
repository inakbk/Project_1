\documentclass[11pt,a4wide]{article}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{a4wide}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvips]{epsfig}
\usepackage[T1]{fontenc}
\usepackage{cite} % [2,3,4] --> [2--4]
\usepackage{shadow}
\usepackage{hyperref}

\setcounter{tocdepth}{2}

\lstset{language=c++}
\lstset{alsolanguage=[90]Fortran}
\lstset{basicstyle=\small}
\lstset{backgroundcolor=\color{white}}
\lstset{frame=single}
\lstset{stringstyle=\ttfamily}
\lstset{keywordstyle=\color{red}\bfseries}
\lstset{commentstyle=\itshape\color{blue}}
\lstset{showspaces=false}
\lstset{showstringspaces=false}
\lstset{showtabs=false}
\lstset{breaklines}

\title{Project 1, FYS-3150}
\author{Ina K. B. Kullmann}
\date{\today}
\begin{document}

\maketitle

\begin{abstract}
The goal for this project is to solve the general one-dimentional Poisson equation with two different numerical methods and compare with the exact analythical solution. For each numerical method the relative error, execution time and number of floating point operations is calculated.

The two numerical methods used to solve the equations is forward/backward substitution and LU-decomposition. Both methods are using linear algebra to turn the problem into a set of many linear equations which can be represented by matrixes. 

%floating point op.?? for lu

\end{abstract}

\section{Introduction: Motivation and Purpose}

%Using text from exercise where it is natural

Many important differential equations in the Sciences can be written as linear second-order differential equations 
\[
\frac{d^2y}{dx^2}+k^2(x)y = f(x),
\]
where $f$ is normally called the inhomogeneous term and $k^2$ is a real function. It is therefore of special interest to be able to solve these kinds of equations. 

A classical equation from electromagnetism is Poisson's equation. The electrostatic potential $\Phi$ is generated by a localized charge distribution $\rho ({\bf r})$.   In three dimensions it reads
\[
\nabla^2 \Phi = -4\pi \rho ({\bf r}).
\]
This can be simplified with a spherically symmetric $\Phi$ and $\rho ({\bf r})$ to:
\[
\frac{1}{r^2}\frac{d}{dr}\left(r^2\frac{d\Phi}{dr}\right) = -4\pi \rho(r),
\]
which is a simple one-dimensional equation. Simplifying further via a substitution $\Phi(r)= \phi(r)/r$ the equation reads:
\[
\frac{d^2\phi}{dr^2}= -4\pi r\rho(r).
\]
We rewrite this equation again by letting $\phi\rightarrow u$ and 
$r\rightarrow x$. Then general one-dimensional \textbf{Poisson equation} reads:
\begin{equation}
-u''(x) = f(x). 
\label{eq:Poisson}
\end{equation}
where the inhomogeneous term $f$ (or source term) is given by the charge distribution $\rho$  multiplied by $r$ and the constant $-4\pi$.

In this project the general equation \ref{eq:Poisson} is the equation of interest that will be solved numerically. The purpose of this is to shed light on how to best solve simple linear second-order differential equations in Physics numerically by using forward/backward substitution and LU-decomposition. 

\section{Theory: Rewriting the equation into a linear algebra problem}
To solve equation \ref{eq:Poisson} we will use Dirichlet boundary conditions and rewrite the equation as a set of linear equations.

In specific we will solve:
\[
-u''(x) = f(x), \hspace{0.5cm} x\in(0,1), \hspace{0.5cm} u(0) = u(1) = 0.
\]
where we assume that the the source term is given by $f(x) = 100e^{-10x}$.  Then the above differential equation
has a closed-form analytical solution given by:
\begin{equation}
u(x) = 1-(1-e^{-10})x-e^{-10x}
\label{eq:analytical_sol}
\end{equation}

For the numerical methods we define the discretized approximation  to $u$ as $v_i$  with grid points $x_i=ih$ in the interval from $x_0=0$ to $x_{n+1}=1$.
The step length or spacing is defined as $h=1/(n+1)$. The boundary conditions gives $v_0 = v_{n+1} = 0$.
We  approximate the second derivative of $u$ with 
\begin{equation}
-\frac{v_{i+1}+v_{i-1}-2v_i}{h^2} = f_i  \hspace{0.5cm} \mathrm{for} \hspace{0.1cm} i=1,\dots, n,
\label{eq:sec_der}
\end{equation}
where $f_i=f(x_i)$.

We can rewrite this equation as a linear set of equations of the form 
\begin{equation}
   {\bf A}{\bf v} = \tilde{{\bf b}}
   \label{eq:linear_eq}
\end{equation}
by rewriting equation \ref{eq:sec_der} as
\[  
   -v_{i+1}-v_{i-1}+2v_i = h^2f_i
\]
so that ${\bf A}$ is an $n\times n$  tridiagonal matrix which we write as 
\begin{equation}
    {\bf A} = \left(\begin{array}{cccccc}
                           2& -1& 0 &\dots   & \dots &0 \\
                           -1 & 2 & -1 &0 &\dots &\dots \\
                           0&-1 &2 & -1 & 0 & \dots \\
                           & \dots   & \dots &\dots   &\dots & \dots \\
                           0&\dots   &  &-1 &2& -1 \\
                           0&\dots    &  & 0  &-1 & 2 \\
                      \end{array} \right)
\end{equation}
and the left hand side is given by $\tilde{b}_i=h^2f_i$. The total set of matrixes must then be given by:

\begin{equation}
{\bf A}{\bf v} = \left(\begin{array}{cccccc}
                           2& -1& 0 &\dots   & \dots &0 \\
                           -1 & 2 & -1 &0 &\dots &\dots \\
                           0&-1 &2 & -1 & 0 & \dots \\
                           & \dots   & \dots &\dots   &\dots & \dots \\
                           0&\dots   &  &-1 &2& -1 \\
                           0&\dots    &  & 0  &-1 & 2 \\
                      \end{array} \right)
                      \left(\begin{array}{c}
                           v_1 \\
                           v_{2}\\
                           v_{3}\\
                           \dots \\
                           v_{n-1}\\
                           v_n\\
                      \end{array} \right) = 
                       \left(\begin{array}{c}
                           h^2f_1 \\
                           h^2f_{2}\\
                           h^2f_{3}\\
                           \dots \\
                           h^2f_{n-1}\\
                           h^2f_n\\
                      \end{array} \right) = 
                      \left(\begin{array}{c}
                           \tilde{b}_1 \\
                           \tilde{b}_2\\
                           \tilde{b}_3\\
                           \dots \\
                           \tilde{b}_{n-1}\\
                           \tilde{b}_n\\
                      \end{array} \right) =
                      \tilde{{\bf b}}
\end{equation}

\subsection{Forward and Backward substitution}
We can rewrite our matrix ${\bf A}$ further in terms of one-dimensional vectors $a,b,c$  of length $1:n$:
\begin{equation}
    {\bf A} = \left(\begin{array}{cccccc}
                           b_1& c_1 & 0 &\dots   & \dots &\dots \\
                           a_2 & b_2 & c_2 &\dots &\dots &\dots \\
                           & a_3 & b_3 & c_3 & \dots & \dots \\
                           & \dots   & \dots &\dots   &\dots & \dots \\
                           &   &  &a_{n-2}  &b_{n-1}& c_{n-1} \\
                           &    &  &   &a_n & b_n \\
                      \end{array} \right)\left(\begin{array}{c}
                           v_1\\
                           v_2\\
                           \dots \\
                          \dots  \\
                          \dots \\
                           v_n\\
                      \end{array} \right)
  =\left(\begin{array}{c}
                           \tilde{b}_1\\
                           \tilde{b}_2\\
                           \dots \\
                           \dots \\
                          \dots \\
                           \tilde{b}_n\\
                      \end{array} \right).
\end{equation}

A tridiagonal matrix is a special form of banded matrix where all the elements are zero except for those on and immediately above and below the leading diagonal. The above tridiagonal system (Equation \ref{eq:linear_eq}) can be written as
\begin{equation}
  a_iv_{i-1}+b_iv_i+c_iv_{i+1} = \tilde{b}_i, \hspace{0.5cm} \mathrm{for} \hspace{0.1cm} i=1,2,\dots,n
\end{equation}
The algorithm for solving this set of equations is rather simple and requires two steps only, a decomposition and forward substitution and a backward substitution. 

%% specific algorithm goes here!! (or in different subsec.)

\subsection{LU Decomposition}
The LU decomposition method means that we can decompose the matrix ${\bf A}$ as the product of two matrices ${\bf L}$ and ${\bf U}$:
\[
{\bf A} = {\bf L}{\bf U}
\]
 The matrix ${\bf L}$ has elements only below the diagonal (and thereby the naming lower) and a matrix ${\bf U}$ contains both the diagonal and matrix elements above the diagonal (leading to the labelling upper). The matrix ${\bf A}$ has an LU factorization if the determinant is different from zero. The LU factorization is unique if A is non-singular.
 
 This factorisation can be used to solve equation \ref{eq:linear_eq} now written as
\[
 {\bf A}{\bf v} = {\bf L}{\bf U}{\bf v} = {\bf \tilde{b}}
\]
exploiting the fact that
\[ 
{\bf U}{\bf v} = {\bf L}^{-1}{\bf \tilde{b}} = {\bf y} \Rightarrow {\bf L}{\bf y} = {\bf \tilde{b}}
\]
to find ${\bf y}$. Then further use the now known ${\bf y}$ to find ${\bf v}$ by solving the much simpler equation:
\[
{\bf U}{\bf v} = {\bf y}
\]


\section{Algorithm}

The algorithms are structured into two \texttt{c++} programs and one \texttt{python} program. Each of the \texttt{c++} programs solves the equations for an nxn matrix, one with the algorithm for forward/backward substitution and the other with the algorithm for LU decomposition. Both algorithms are described below. After solving the equations the result vector $v$ is written to a \texttt{.txt} file along with the $x$ value and execution time. The value of n is given on the command line so that the program is executed one time for each n. 

The python program compiles and runs the \texttt{c++} program\footnote{The aim was to only have one \texttt{c++} progam, but when I tried running the \texttt{c++} code with the LU decomposition from the python script i got a compilation error. The same compilation error came when running from the terminal, but not from QT creator. So with little time to finish the project i fixed the problem by running the LU decomposition from QT Creator before running the python script. } so that the \texttt{.txt} files are given, loads and plots the data along with the analytical solution and computes and plots the relative error. 




%%explaining main structure

\subsection{Forward and Backward substitution}
The purpose of the forward and backward substitution is to make row operations on both left/right hand side of the equation so that at the left hand side eventually is left with the identity matrix times the unknown vector, ${\bf A} \rightarrow {\bf A}^* \rightarrow {\bf I}$ and ${\bf \tilde{b}} \rightarrow {\bf \tilde{b}}^*$ so the solution is then the altered left hand side:
\[
{\bf I}{\bf v} = {\bf v} = {\bf \tilde{b}}^*
\]
where * is meaning that the matrix in the algorithm now obtains a new value.

In our case we have a very special tridiagonal matrix ${\bf A}$, so we only need two operations to get the identity matrix. 

We start by the forward substitution which removes the elements below the diagonal from the second comumn and down to the n-th row. The algorithm is as follows:
\begin{align*}
b_i^* &= b_i - \frac{a_i c_{i-1}}{b_{i-1}}\\
\tilde{b}_i^* &= \tilde{b}_i - \frac{a_i}{b_{i-1}}\tilde{b}_{i-1}, \hspace{0.5cm} \mathrm{for} \hspace{0.1cm} i=2,\dots,n
\end{align*}

We can also rewrite $a_i = a = -1$ and $c_i = c = -1$ for all $i$ to reduce the number of floating point operations:
\begin{align*}
b_i^* &= b_i - \frac{1}{b_{i-1}}\\
\tilde{b}_i^* &= \tilde{b}_i + \frac{\tilde{b}_{i-1}}{b_{i-1}}
\end{align*}

The backward substitution then removes all the elements above the diagonal from the next bottom row (n-1) of the matrix and up to row number one.
\begin{align*}
\tilde{b}_{i-1}^* &= \tilde{b}_{i-1} - \frac{\tilde{b}_{i}}{b_{i}}, \hspace{0.5cm} \mathrm{for} \hspace{0.1cm} i=n,\dots,2
\end{align*}
where $c= -1$ as above. This iteration does not affect the $b_i$ since elements under the diagonal, $a_i^*$, is zero after the forward substitution. 

Finally we normalize the left hand side to one to obtain the identity matrix, meaning that the right hand side is:
\[
\tilde{b}_i^{**} = \frac{\tilde{b}_i^*}{b_i}
\]
so that the solution of the set of equations is $v_i = \tilde{b}_i^{**}$. 

Then the precice number of floating point operations needed to solve this set of equations is seven times the number of rows the algorithm iterates over which is n-1. 

\subsection{LU Decomposition}
To solve the equations by LU decomposition we use the Armadillo library functions \texttt{lu(L,U,A)} and \texttt{solve(A,B)} with the simple code:
\begin{lstlisting}
    lu(L,U,A);
    vec y = solve(L,b_thilde);
    vec v = solve(U,y);
\end{lstlisting}


Find also the precise number of floating point 
operations needed to solve the above equations. ?!?

\subsection{Relative error}
The relative error in the data set in relation to the analytical solution can be computed by 
\[
   \epsilon_i=log_{10}\left(\left|\frac{v_i-u_i}
                 {u_i}\right|\right),
\]
where $\epsilon_i$ is the relative error for each corresponding value of $x_i$ where $i=1,\dots, n$. 

It can be shown that the relative error is constant over the whole data set (for one $n$). We will therefor choose the relative error for each $n$, $\epsilon$ to be the mean of the relative error for the whole dataset, $\epsilon_i$
\[
\epsilon = \frac{\epsilon_1 + \epsilon_2 + \dots + \epsilon_n}{n}
\]
We will let n be an element of $N = [10^1, 10^2, \dots, 10^5]$ plot the relative error for all the different $n$-values as a function of $log_{10}(h)$ 


%%Make a table of the results and comment your results. 


\subsection{Calculating execution time}

To compute the elapsed time in c++ you can use the following statements
\begin{lstlisting}[title={Time in C++}]
using namespace std;
...
#include "time.h"   //  you have to include the time.h header
int main()
{
    // declarations of variables 
    ...
    clock_t start, finish;  //  declare start and final time
    start = clock();
    // your code is here, do something and then get final time
    finish = clock();
    ( (finish - start)/CLOCKS_PER_SEC );
...
\end{lstlisting}




\rule{\textwidth}{1pt}
\textbf{Exercise:}\\
Your first task is to set up the algorithm for solving this set of linear equations.
Find also the precise number of floating point 
operations needed to solve the above equations. 
Compare this with standard Gaussian elimination and LU decomposition.

Then you should code the above algorithm and solve the problem for matrices of the size
$10\times 10$, $100\times 100$ and $1000\times 1000$.  That means that you choose $n=10$, $n=100$ and
$n=1000$ grid points. 

Compare your results (make plots) with the closed-form solution for the different number of grid points  in the 
interval $x\in(0,1)$.  The different number of grid points corresponds to different step lengths $h$.

sdkjcfnwif
\rule{\textwidth}{1pt}


Compute the relative error  in the data set $i=1,\dots, n$,by setting up 
\[
   \epsilon_i=log_{10}\left(\left|\frac{v_i-u_i}
                 {u_i}\right|\right),
\]
as function of $log_{10}(h)$ for the function values $u_i$ and $v_i$.
For each step length extract the max value of the relative error.  
Try to increase $n$ to $n=10000$ and $n=10^5$.  Make a table of the results and 
comment your results. 

Compare your results with those from the LU decomposition codes for the matrix of sizes $10\times 10$, $100\times 100$ and
$1000\times 1000$. Here you should use the library functions provided  on the webpage of the course. Alternatively, if you use armadillo as a library, you can use the similar function for LU decomposition.  The armadillo function for the LU decomposition is called $LU$ while the function for solving linear sets of equations is called $solve$.
Use for example the unix function {\em time} when you run your codes 
and compare the time usage between LU decomposition and  your
tridiagonal solver.   Alternatively, you can use the functions in C++, Fortran or Python that measure the time used. 

Make a table of the results and comment the differences
in execution time
How many floating point operations does the LU decomposition use to solve the set of linear equations?
Can you run the standard LU decomposition
for a matrix of the size $10^5\times 10^5$?
Comment your results.


To compute the elapsed time in c++ you can use the following statements
\begin{lstlisting}[title={Time in C++}]
using namespace std;
...
#include "time.h"   //  you have to include the time.h header
int main()
{
    // declarations of variables 
    ...
    clock_t start, finish;  //  declare start and final time
    start = clock();
    // your code is here, do something and then get final time
    finish = clock();
    ( (finish - start)/CLOCKS_PER_SEC );
...
\end{lstlisting}



-----------------------------------------------

\newpage
\section*{ README before delivery:}

\section*{Introduction to numerical projects}

Here follows a brief recipe and recommendation on how to write a report for each
project.
\begin{itemize}
\item Give a short description of the nature of the problem and the eventual 
numerical methods you have used.
\item Describe the algorithm you have used and/or developed. Here you may find it convenient
to use pseudocoding. In many cases you can describe the algorithm
in the program itself.

\item Include the source code of your program. Comment your program properly.
\item If possible, try to find analytic solutions, or known limits
in order to test your program when developing the code.
\item Include your results either in figure form or in a table. Remember to
       label your results. All tables and figures should have relevant captions
       and labels on the axes.
\item Try to evaluate the reliabilty and numerical stability/precision
of your results. If possible, include a qualitative and/or quantitative
discussion of the numerical stability, eventual loss of precision etc. 

\item Try to give an interpretation of you results in your answers to 
the problems.
\item Critique: if possible include your comments and reflections about the 
exercise, whether you felt you learnt something, ideas for improvements and 
other thoughts you've made when solving the exercise.
We wish to keep this course at the interactive level and your comments can help
us improve it.
\item Try to establish a practice where you log your work at the 
computerlab. You may find such a logbook very handy at later stages
in your work, especially when you don't properly remember 
what a previous test version 
of your program did. Here you could also record 
the time spent on solving the exercise, various algorithms you may have tested
or other topics which you feel worthy of mentioning.
\end{itemize}



\section*{Format for electronic delivery of report and programs}
%
The preferred format for the report is a PDF file. You can also
use DOC or postscript formats or as an ipython notebook file. 
As programming language we prefer that you choose between C/C++, Fortran2008 or Python.
The following prescription should be followed when preparing the report:
\begin{itemize}
\item Use Devilry to hand in your projects, log in  at 
\url{ http://devilry.ifi.uio.no} with your normal UiO username and password
and choose either 'fys3150' or 'fys4150'.
There you can load up the files within the deadline.
\item Upload {\bf only} the report file!  For the source code file(s) you have developed please provide us with your link to your github domain. 
The report file should include all of your discussions and a list of the codes you have developed. 
Do not include library files which are available at the course homepage, unless you have
made specific changes to them.
\item In your git repository, please include a folder which contains selected results. These can be in the form of output from your code
for a selected set of runs and input parameters. 
\item Comments  from us on your projects, approval or not, corrections to be made 
etc can be found under
your Devilry domain and are only visible to you and the teachers of the course.

\end{itemize}

Finally, 
we encourage you to work two and two together. Optimal working groups consist of 
2-3 students. You can then hand in a common report. 
\end{document}

